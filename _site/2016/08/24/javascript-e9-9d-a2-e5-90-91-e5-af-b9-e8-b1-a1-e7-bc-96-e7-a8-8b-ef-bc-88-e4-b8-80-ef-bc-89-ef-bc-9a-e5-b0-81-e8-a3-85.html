<!DOCTYPE html>
<html>
<head>
    
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    

    

    

    
    <title>Javascript 面向对象编程（一）：封装</title>
    <meta name="description" content="人生不是要过的怎样，而是要懂得怎样去过。" />

    
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    
    <link rel="shortcut icon" href="/assets/favicon.ico">

    
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />


    
    
</head>
<body class="post-template nav-closed">

    
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        
            <li class="nav-" role="presentation"><a href="/">Home</a></li>
        
            <li class="nav-" role="presentation"><a href="/aboutme">关于我</a></li>
        
    </ul>
    
        <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>
    
</div>
<span class="nav-cover"></span>



    <div class="site-wrapper">

        
        <header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">
    <article class="post">

        <header class="post-header">
            <h1 class="post-title">Javascript 面向对象编程（一）：封装</h1>
            <section class="post-meta">
                <time class="post-date" datetime="2016-08-24">24 August 2016</time> 
            </section>
        </header>

        <section class="post-content">
            <p>作者：阮一峰</p>

<p>Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有<code class="highlighter-rouge">class</code>（类）。</p>

<p>那么，如果我们要把”属性”（property）和”方法”（method），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？</p>

<p>一、 生成实例对象的原始模式</p>

<p>假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。</p>

<blockquote>
  <p>　　var Cat = {　　　　name : ”,</p>

  <p>color : ”</p>

  <p>}</p>
</blockquote>

<p>现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。</p>

<blockquote>
  <p>　　var cat1 = {}; // 创建一个空对象</p>

  <p>cat1.name = “大毛”; // 按照原型对象的属性赋值</p>

  <p>cat1.color = “黄色”;</p>

  <p>var cat2 = {};</p>

  <p>cat2.name = “二毛”;</p>

  <p>cat2.color = “黑色”;</p>
</blockquote>

<p>好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>

<p>二、 原始模式的改进</p>

<p>我们可以写一个函数，解决代码重复的问题。</p>

<blockquote>
  <p>　　function Cat(name,color) {</p>

  <p>return {</p>

  <p>name:name,</p>

  <p>color:color</p>

  <p>}</p>

  <p>}</p>
</blockquote>

<p>然后生成实例对象，就等于是在调用函数：</p>

<blockquote>
  <p>　　var cat1 = Cat(“大毛”,”黄色”);</p>

  <p>var cat2 = Cat(“二毛”,”黑色”);</p>
</blockquote>

<p>这种方法的问题依然是，<code class="highlighter-rouge">cat1</code>和<code class="highlighter-rouge">cat2</code>之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p>

<p>三、 构造函数模式</p>

<p>为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。</p>

<p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了<a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html"><code class="highlighter-rouge">this</code>变量</a>。对构造函数使用<code class="highlighter-rouge">new</code>运算符，就能生成实例，并且<code class="highlighter-rouge">this</code>变量会绑定在实例对象上。</p>

<p>比如，猫的原型对象现在可以这样写，</p>

<blockquote>
  <p>　　function Cat(name,color){</p>

  <p>this.name=name;</p>

  <p>this.color=color;</p>

  <p>}</p>
</blockquote>

<p>我们现在就可以生成实例对象了。</p>

<blockquote>
  <p>　　var cat1 = new Cat(“大毛”,”黄色”);</p>

  <p>var cat2 = new Cat(“二毛”,”黑色”);</p>

  <p>alert(cat1.name); // 大毛</p>

  <p>alert(cat1.color); // 黄色</p>
</blockquote>

<p>这时<code class="highlighter-rouge">cat1</code>和<code class="highlighter-rouge">cat2</code>会自动含有一个<code class="highlighter-rouge">constructor</code>属性，指向它们的构造函数。</p>

<blockquote>
  <p>　　alert(cat1.constructor == Cat); //true</p>

  <p>alert(cat2.constructor == Cat); //true</p>
</blockquote>

<p>Javascript还提供了一个<code class="highlighter-rouge">instanceof</code>运算符，验证原型对象与实例对象之间的关系。</p>

<blockquote>
  <p>　　alert(cat1 instanceof Cat); //true</p>

  <p>alert(cat2 instanceof Cat); //true</p>
</blockquote>

<p>四、构造函数模式的问题</p>

<p>构造函数方法很好用，但是存在一个浪费内存的问题。</p>

<p>请看，我们现在为<code class="highlighter-rouge">Cat</code>对象添加一个不变的属性<code class="highlighter-rouge">type</code>（种类），再添加一个方法<code class="highlighter-rouge">eat</code>（吃）。那么，原型对象<code class="highlighter-rouge">Cat</code>就变成了下面这样：</p>

<blockquote>
  <p>　　function Cat(name,color){</p>

  <p>this.name = name;</p>

  <p>this.color = color;</p>

  <p>this.type = “猫科动物”;</p>

  <p>this.eat = function(){alert(“吃老鼠”);};</p>

  <p>}</p>
</blockquote>

<p>还是采用同样的方法，生成实例：</p>

<blockquote>
  <p>　　var cat1 = new Cat(“大毛”,”黄色”);</p>

  <p>var cat2 = new Cat (“二毛”,”黑色”);</p>

  <p>alert(cat1.type); // 猫科动物</p>

  <p>cat1.eat(); // 吃老鼠</p>
</blockquote>

<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，<code class="highlighter-rouge">type</code>属性和<code class="highlighter-rouge">eat()</code>方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。</p>

<blockquote>
  <p>　　alert(cat1.eat == cat2.eat); //false</p>
</blockquote>

<p>能不能让<code class="highlighter-rouge">type</code>属性和<code class="highlighter-rouge">eat()</code>方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。</p>

<p>五、 Prototype模式</p>

<p>Javascript规定，每一个构造函数都有一个<code class="highlighter-rouge">prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>

<p>这意味着，我们可以把那些不变的属性和方法，直接定义在<code class="highlighter-rouge">prototype</code>对象上。</p>

<blockquote>
  <p>　　function Cat(name,color){</p>

  <p>this.name = name;</p>

  <p>this.color = color;</p>

  <p>}</p>

  <p>Cat.prototype.type = “猫科动物”;</p>

  <p>Cat.prototype.eat = function(){alert(“吃老鼠”)};</p>
</blockquote>

<p>然后，生成实例。</p>

<blockquote>
  <p>　　var cat1 = new Cat(“大毛”,”黄色”);</p>

  <p>var cat2 = new Cat(“二毛”,”黑色”);</p>

  <p>alert(cat1.type); // 猫科动物</p>

  <p>cat1.eat(); // 吃老鼠</p>
</blockquote>

<p>这时所有实例的<code class="highlighter-rouge">type</code>属性和<code class="highlighter-rouge">eat()</code>方法，其实都是同一个内存地址，指向<code class="highlighter-rouge">prototype</code>对象，因此就提高了运行效率。</p>

<blockquote>
  <p>　　alert(cat1.eat == cat2.eat); //true</p>
</blockquote>

<p>六、 Prototype模式的验证方法</p>

<p>为了配合<code class="highlighter-rouge">prototype</code>属性，Javascript定义了一些辅助方法，帮助我们使用它。，</p>

<p>6.1 isPrototypeOf()</p>

<p>这个方法用来判断，某个<code class="highlighter-rouge">proptotype</code>对象和某个实例之间的关系。</p>

<blockquote>
  <p>　　alert(Cat.prototype.isPrototypeOf(cat1)); //true</p>

  <p>alert(Cat.prototype.isPrototypeOf(cat2)); //true</p>
</blockquote>

<p>6.2 hasOwnProperty()</p>

<p>每个实例对象都有一个<code class="highlighter-rouge">hasOwnProperty()</code>方法，用来判断某一个属性到底是本地属性，还是继承自<code class="highlighter-rouge">prototype</code>对象的属性。</p>

<blockquote>
  <p>　　alert(cat1.hasOwnProperty(“name”)); // true</p>

  <p>alert(cat1.hasOwnProperty(“type”)); // false</p>
</blockquote>

<p>6.3 in运算符</p>

<p><code class="highlighter-rouge">in</code>运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>

<blockquote>
  <p>　　alert(“name” in cat1); // true</p>

  <p>alert(“type” in cat1); // true</p>
</blockquote>

<p><code class="highlighter-rouge">in</code>运算符还可以用来遍历某个对象的所有属性。</p>

<blockquote>
  <p>　　for(var prop in cat1) { alert(“cat1[“+prop+”]=”+cat1[prop]); }</p>
</blockquote>

<p>未完，请继续阅读这个系列的第二部分《构造函数的继承》和第三部分《非构造函数的继承》。</p>

<p>转至：http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html</p>

<p>未经允许不得转载：<a href="http://kongqia.com">空洽网</a> » <a href="http://kongqia.com/33725.html">Javascript 面向对象编程（一）：封装</a></p>


        </section>

        <footer class="post-footer">

        
        
        
        

            <section class="share">
                <h4>Share this post</h4>
                <a class="icon-twitter" href="https://twitter.com/intent/tweet?text=Javascript%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E4%B8%80):%E5%B0%81%E8%A3%85&amp;url=/2016/08/24/javascript-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-bc-96-e7-a8-8b-ef-bc-88-e4-b8-80-ef-bc-89-ef-bc-9a-e5-b0-81-e8-a3-85.html"
                    onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <span class="hidden">Twitter</span>
                </a>
                <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=/2016/08/24/javascript-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-bc-96-e7-a8-8b-ef-bc-88-e4-b8-80-ef-bc-89-ef-bc-9a-e5-b0-81-e8-a3-85.html"
                    onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <span class="hidden">Facebook</span>
                </a>
                <a class="icon-google-plus" href="https://plus.google.com/share?url=/2016/08/24/javascript-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-bc-96-e7-a8-8b-ef-bc-88-e4-b8-80-ef-bc-89-ef-bc-9a-e5-b0-81-e8-a3-85.html"
                   onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <span class="hidden">Google+</span>
                </a>
            </section>

            
            

        </footer>

    </article>
</main>


<aside class="read-next">
    
    <a class="read-next-story no-cover" href="/2016/08/24/javascript-e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-bc-96-e7-a8-8b-ef-bc-88-e4-ba-8c-ef-bc-89-ef-bc-9a-e6-9e-84-e9-80-a0-e5-87-bd-e6-95-b0-e7-9a-84-e7-b.html">
        <section class="post">
            <h2>Javascript面向对象编程（二）：构造函数的继承</h2>
            <p>这个系列的第一部分，主要介绍了如何”封装”数据和方法，以及如何从原型对象生成实例。

&hellip;</p>
        </section>
    </a>
    
    
    <a class="read-next-story prev no-cover" href="/2016/08/05/error-lnk-2001.html">
        <section class="post">
            <h2>error lnk 2001</h2>
            <p>出现error lnk 2001 无法解析的外部符号，若提示出错函数为自定义函数，出错原因为：只对函数进行了声明而没有实现。处理方法：检查是否函数已经实现，且与声明一致。

&hellip;</p>
        </section>
    </a>
    
</aside>


        
        <footer class="site-footer clearfix">
            <section class="copyright"><a href=""></a> &copy; 2020</section>
            <section class="poweredby">Casper theme by <a href="https://ghost.org">Ghost</a>, adopted to Jekyll by <a href="https://github.com/Jinmo/jekyll-casper">Jinmo</a></section>
        </footer>

    </div>

    
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
    
    
    
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    
    <script type="text/javascript" src="/assets/js/index.js"></script>

</body>
</html>
