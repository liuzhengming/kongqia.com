<!DOCTYPE html>
<html>
<head>
    
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    

    

    

    
    <title>“流式”前端构建工具—gulp.js 简介</title>
    <meta name="description" content="人生不是要过的怎样，而是要懂得怎样去过。" />

    
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    
    <link rel="shortcut icon" href="/assets/favicon.ico">

    
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />


    
    
</head>
<body class="post-template nav-closed">

    
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        
            <li class="nav-" role="presentation"><a href="/">Home</a></li>
        
            <li class="nav-" role="presentation"><a href="/authors/editme/">Author</a></li>
        
    </ul>
    
        <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>
    
</div>
<span class="nav-cover"></span>



    <div class="site-wrapper">

        
        <header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">
    <article class="post">

        <header class="post-header">
            <h1 class="post-title">“流式”前端构建工具—gulp.js 简介</h1>
            <section class="post-meta">
                <time class="post-date" datetime="2015-01-31">31 January 2015</time> 
            </section>
        </header>

        <section class="post-content">
            <p> </p>

<p><a href="http://gruntjs.com/">Grunt</a> 一直是前端领域构建工具（任务运行器或许更准确一些，因为前端构建只是此类工具的一部分用途）的王者，然而它也不是毫无缺陷的，近期风头正劲的 <a href="http://gulpjs.com/">gulp.js</a> 隐隐有取而代之的态势。那么，究竟是什么使得 gulp.js 备受关注呢？</p>

<h2 id="grunt-之殇">Grunt 之殇</h2>

<p>gulp.js 的作者 <a href="http://github.com/Contra">Eric Schoffstall</a> 在他<a href="http://slid.es/contra/gulp">介绍 gulp.js 的 presentation</a> 中总结了 Grunt 的几点不足之处：</p>

<ol>
  <li><strong>插件很难遵守单一责任原则</strong>。因为 Grunt 的 API 设计缺憾，使得许多插件不得不负责一些和其主要任务无关的事情。比如说要对处理后的文件进行更名操作，你可能使用的是 <code class="highlighter-rouge">uglify</code> 插件，也有可能使用的是 <code class="highlighter-rouge">concat</code> 插件（取决于工作流的最后一个环节是谁）。
    <blockquote>
      <p>我的看法：这或许是个问题，对很多人来说 Grunt 插件多少存在“职责不明”和“越俎代庖”的情况。在我看来，这也是 Grunt 一个设计思想：把对文件的操作抽象为一个<a href="http://gruntjs.com/configuring-tasks#files">独立的组件（Files）</a>，任何插件都以相同的规则来使用它。遗憾在于，使用它的过程发生在每个插件的独立配置对象里，所以总给人一种“把不该这个插件做的事情丢给它来做”的别扭感觉。</p>
    </blockquote>
  </li>
  <li><strong>用插件做一些本来不需要插件来做的事情</strong>。因为 Grunt 提供了统一的 CLI 入口，子任务由插件定义，由 CLI 命令来调用执行，因此哪怕是很简单的外部命令（比如说运行 <code class="highlighter-rouge">karma start</code>）都得有一个插件来负责封装它，然后再变成 Grunt CLI 命令的参数来运行，多此一举。
    <blockquote>
      <p>我的看法：举双手双脚赞成！</p>
    </blockquote>
  </li>
  <li><strong>试图用配置文件完成所有事，结果就是混乱不堪</strong>。规模较大，构建／分发／部署流程较为复杂的项目，其 <code class="highlighter-rouge">Gruntfile</code>有多庞杂相信有经历的人都有所体会。而 gulp.js 奉行的是“写程序而不是写配置”，它走的是一种 <em>node way</em>。
    <blockquote>
      <p>我的看法：对于 node.js 开发者来说这是好事，符合他们的一贯作风；不过对于那些纯前端工程师来说（数量不小），这似乎没有什么显著的改善。况且近来 Grunt 社区涌现了不少插件来帮助开发者<a href="http://www.html5rocks.com/en/tutorials/tooling/supercharging-your-gruntfile/">组织／管理／简化臃肿的 <code class="highlighter-rouge">Gruntfile</code></a>，效果都还不错。所以关于这一点，就见仁见智吧。</p>
    </blockquote>
  </li>
  <li><strong>落后的流程控制产生了让人头痛的临时文件／文件夹所导致的性能滞后</strong>。这是 gulp.js 下刀子的重点，也是本标题里“流式构建”所解决的根本问题。流式构建改变了底层的流程控制，大大提高了构建工作的效率和性能，给用户的直观感觉就是：更快。
    <blockquote>
      <p>我的看法：关于流式构建，短短几句话无法讲清它的来龙去脉，但是在 node.js 的世界里，<code class="highlighter-rouge">streaming</code> 确实是至关重要的。我推荐一份阅读材料：<a href="http://github.com/substack/stream-handbook">Stream Handbook</a>，读过之后相信心里就有数了。</p>
    </blockquote>
  </li>
</ol>

<p>作为对比和总结，作者列出了 gulp.js 的五大特点：</p>

<ol>
  <li>使用 gulp.js，你的构建脚本是代码，而不是配置文件；</li>
  <li>使用标准库（node.js standard library）来编写脚本；</li>
  <li>插件都很简单，只负责完成一件事－基本上都是 20 行左右的函数；</li>
  <li>任务都以最大的并发数来执行；</li>
  <li>输入／输出（I/O）是基于“流式”的。</li>
</ol>

<h2 id="gulpjs-之道">gulp.js 之道</h2>

<p><a href="http://github.com/gulpjs/gulp/blob/master/docs/README.md">gulp.js 的官方文档</a>都在 Github 上，本文是一个简介，更具体的细节还请自行阅读文档。在这里我就 gulp.js 的安装和使用流程做一个简述，先一起来领略一下 gulp.js 的风采吧。</p>

<h3 id="第一步安装命令行工具">第一步：安装命令行工具</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;code class="lang-shell"&gt;&lt;span class="hljs-variable"&gt;$ &lt;/span&gt;npm install -g gulp
</code></pre>
</div>

<h3 id="第二步在你的项目下把-gulp-安装为开发依赖组件假设你已经创建好了packagejson">第二步：在你的项目下把 gulp 安装为开发依赖组件（假设你已经创建好了 <code class="highlighter-rouge">package.json</code>）</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;code class="lang-shell"&gt;&lt;span class="hljs-variable"&gt;$ &lt;/span&gt;cd &lt;&lt;span class="hljs-constant"&gt;YOUR_PROJECT&lt;/span&gt;&gt;
&lt;span class="hljs-variable"&gt;$ &lt;/span&gt;npm install gulp --save-dev
</code></pre>
</div>

<h3 id="第三步在项目的根路径下创建gulpfilejs初始内容为">第三步：在项目的根路径下创建 <code class="highlighter-rouge">Gulpfile.js</code>，初始内容为：</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;code class="lang-javascript"&gt;&lt;span class="hljs-keyword"&gt;var&lt;/span&gt; gulp = &lt;span class="hljs-built_in"&gt;require&lt;/span&gt;(&lt;span class="hljs-string"&gt;'gulp'&lt;/span&gt;);

gulp.task(&lt;span class="hljs-string"&gt;'default'&lt;/span&gt;, &lt;span class="hljs-function"&gt;&lt;span class="hljs-keyword"&gt;function&lt;/span&gt;&lt;span class="hljs-params"&gt;()&lt;/span&gt;&lt;/span&gt;{
});
</code></pre>
</div>

<h3 id="第四步运行">第四步：运行！</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;code class="lang-shell"&gt;&lt;span class="hljs-variable"&gt;$ &lt;/span&gt;gulp
</code></pre>
</div>

<p>So far so good! 看起来和 Grunt 没差太远吧？的确如此，gulp.js 的学习曲线还是相当平缓的。接下来，为了能够顺利的编写构建脚本，我们来学习几个核心的 API 函数——别担心，gulp.js 的 API 非常简单，我们只需要了解四个就足以应对绝大多数的脚本编写了（而且用过 Grunt 的话，这四个都不是什么新鲜货）。</p>

<ul>
  <li><a href="http://github.com/gulpjs/gulp/blob/master/docs/API.md#gulptaskname-deps-fn"><code class="highlighter-rouge">gulp.task(name[, deps], fn)</code></a>：注册任务<br />
<code class="highlighter-rouge">name</code> 是任务名称；<code class="highlighter-rouge">deps</code> 是可选的数组，其中列出需要在本任务运行要执行的任务；<code class="highlighter-rouge">fn</code> 是任务体，这是 gulp.js 的核心了，需要花时间吃透它，<a href="http://github.com/gulpjs/gulp/blob/master/docs/API.md#fn">详情见此</a>。</li>
  <li><a href="http://github.com/gulpjs/gulp/blob/master/docs/API.md#gulpsrcglobs-options"><code class="highlighter-rouge">gulp.src(globs[, options])</code></a>：指明源文件路径<br />
 用过 Grunt 的话，<code class="highlighter-rouge">globs</code> 一定不会陌生，这里没什么变化；<code class="highlighter-rouge">options</code> 是可选的，具体请查看 <a href="http://github.com/gulpjs/gulp/blob/master/docs/API.md#options">gulp.js API</a></li>
  <li><a href="http://github.com/gulpjs/gulp/blob/master/docs/API.md#gulpdestpath"><code class="highlighter-rouge">gulp.dest(path)</code></a>：指明任务处理后的目标输出路径</li>
  <li><a href="http://github.com/gulpjs/gulp/blob/master/docs/API.md#gulpwatchglob--opts-tasks-or-gulpwatchglob--opts-cb"><code class="highlighter-rouge">gulp.watch(glob[, options], tasks)／gulp.watch(glob[, options, cb])</code></a>：监视文件的变化并运行相应的任务。你没看错，<code class="highlighter-rouge">watch</code> 作为核心 API 出现在 gulp.js 里了，具体用法还是要多看<a href="http://github.com/gulpjs/gulp/blob/master/docs/API.md#gulpwatchglob--opts-tasks-or-gulpwatchglob--opts-cb">文档</a>，不过接下来我们会演示简单的例子。</li>
</ul>

<h3 id="范例">范例</h3>

<p>我们练习一个最常见的范例，写一个 node.js 程序时所需要的构建脚本。为此我们要做三件事情（括号内列出对应插件的名字，<a href="http://gulpjs.com/plugins/">更多插件请到此处寻找</a>）：</p>

<ol>
  <li>语法检查（<code class="highlighter-rouge">gulp-jshint</code>）</li>
  <li>合并文件（<code class="highlighter-rouge">gulp-concat</code>）</li>
  <li>压缩代码（<code class="highlighter-rouge">gulp-uglify</code>）</li>
</ol>

<p>另外，我们可能还需要文件更名操作，所以 <code class="highlighter-rouge">gulp-rename</code> 也会很有用。接着我们需要先在项目下安装这些插件：</p>

<p><code class="highlighter-rouge">&lt;code class="lang-shell"&gt;&lt;span class="hljs-input"&gt;&lt;span class="hljs-prompt"&gt;$ npm install &lt;PLUGIN_NAME&gt;&lt;/span&gt; --save-dev&lt;/span&gt;</code></p>

<p>最后我们完成所有任务的编写，完整的代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;code class="lang-javascript"&gt;&lt;span class="hljs-keyword"&gt;var&lt;/span&gt; gulp = &lt;span class="hljs-built_in"&gt;require&lt;/span&gt;(&lt;span class="hljs-string"&gt;'gulp'&lt;/span&gt;);
&lt;span class="hljs-keyword"&gt;var&lt;/span&gt; jshint = &lt;span class="hljs-built_in"&gt;require&lt;/span&gt;(&lt;span class="hljs-string"&gt;'gulp-jshint'&lt;/span&gt;);
&lt;span class="hljs-keyword"&gt;var&lt;/span&gt; concat = &lt;span class="hljs-built_in"&gt;require&lt;/span&gt;(&lt;span class="hljs-string"&gt;'gulp-concat'&lt;/span&gt;);
&lt;span class="hljs-keyword"&gt;var&lt;/span&gt; uglify = &lt;span class="hljs-built_in"&gt;require&lt;/span&gt;(&lt;span class="hljs-string"&gt;'gulp-uglify'&lt;/span&gt;);
&lt;span class="hljs-keyword"&gt;var&lt;/span&gt; rename = &lt;span class="hljs-built_in"&gt;require&lt;/span&gt;(&lt;span class="hljs-string"&gt;'gulp-rename'&lt;/span&gt;);

&lt;span class="hljs-comment"&gt;// 语法检查&lt;/span&gt;
gulp.task(&lt;span class="hljs-string"&gt;'jshint'&lt;/span&gt;, &lt;span class="hljs-function"&gt;&lt;span class="hljs-keyword"&gt;function&lt;/span&gt;&lt;span class="hljs-params"&gt;()&lt;/span&gt;&lt;/span&gt;{
    &lt;span class="hljs-keyword"&gt;return&lt;/span&gt; gulp.src(&lt;span class="hljs-string"&gt;'src/*.js'&lt;/span&gt;)
        .pipe(jshint())
        .pipe(jshint.reporter(&lt;span class="hljs-string"&gt;'default'&lt;/span&gt;));
});

&lt;span class="hljs-comment"&gt;// 合并文件之后压缩代码&lt;/span&gt;
gulp.task(&lt;span class="hljs-string"&gt;'minify'&lt;/span&gt;, &lt;span class="hljs-function"&gt;&lt;span class="hljs-keyword"&gt;function&lt;/span&gt;&lt;span class="hljs-params"&gt;()&lt;/span&gt;&lt;/span&gt;{
     &lt;span class="hljs-keyword"&gt;return&lt;/span&gt; gulp.src(&lt;span class="hljs-string"&gt;'src/*.js'&lt;/span&gt;)
        .pipe(concat(&lt;span class="hljs-string"&gt;'all.js'&lt;/span&gt;))
        .pipe(gulp.dest(&lt;span class="hljs-string"&gt;'dist'&lt;/span&gt;))
        .pipe(uglify())
        .pipe(rename(&lt;span class="hljs-string"&gt;'all.min.js'&lt;/span&gt;))
        .pipe(gulp.dest(&lt;span class="hljs-string"&gt;'dist'&lt;/span&gt;));
});

&lt;span class="hljs-comment"&gt;// 监视文件的变化&lt;/span&gt;
gulp.task(&lt;span class="hljs-string"&gt;'watch'&lt;/span&gt;, &lt;span class="hljs-function"&gt;&lt;span class="hljs-keyword"&gt;function&lt;/span&gt;&lt;span class="hljs-params"&gt;()&lt;/span&gt;&lt;/span&gt;{
    gulp.watch(&lt;span class="hljs-string"&gt;'src/*.js'&lt;/span&gt;, [&lt;span class="hljs-string"&gt;'jshint'&lt;/span&gt;, &lt;span class="hljs-string"&gt;'minify'&lt;/span&gt;]);
});

&lt;span class="hljs-comment"&gt;// 注册缺省任务&lt;/span&gt;
gulp.task(&lt;span class="hljs-string"&gt;'default'&lt;/span&gt;, [&lt;span class="hljs-string"&gt;'jshint'&lt;/span&gt;, &lt;span class="hljs-string"&gt;'minify'&lt;/span&gt;, &lt;span class="hljs-string"&gt;'watch'&lt;/span&gt;]);
</code></pre>
</div>

<p>可以看出，基本上所有的任务体都是这么个模式：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;code class="lang-javascript"&gt;gulp.task(&lt;span class="hljs-string"&gt;'任务名称'&lt;/span&gt;, &lt;span class="hljs-function"&gt;&lt;span class="hljs-keyword"&gt;function&lt;/span&gt;&lt;span class="hljs-params"&gt;()&lt;/span&gt;&lt;/span&gt;{
    &lt;span class="hljs-keyword"&gt;return&lt;/span&gt; gulp.src(&lt;span class="hljs-string"&gt;'文件'&lt;/span&gt;)
        .pipe(...)
        .pipe(...)
        &lt;span class="hljs-comment"&gt;// 直到任务的最后一步&lt;/span&gt;
        .pipe(...);
});
</code></pre>
</div>

<p>非常容易理解！获取要处理的文件，传递给下一个环节处理，然后把返回的结果继续传递给下一个环节……直到所有环节完成。<code class="highlighter-rouge">pipe</code> 就是 <code class="highlighter-rouge">stream</code> 模块里负责传递流数据的方法而已，至于最开始的 <code class="highlighter-rouge">return</code> 则是把整个任务的 <code class="highlighter-rouge">stream</code> 对象返回出去，以便任务和任务可以依次传递执行。</p>

<p>或许写成这样会更直观：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;code class="lang-javascript"&gt;gulp.task(&lt;span class="hljs-string"&gt;'task_name'&lt;/span&gt;, &lt;span class="hljs-function"&gt;&lt;span class="hljs-keyword"&gt;function&lt;/span&gt;&lt;span class="hljs-params"&gt;()&lt;/span&gt;&lt;/span&gt;{
    &lt;span class="hljs-keyword"&gt;var&lt;/span&gt; stream = gulp.src(&lt;span class="hljs-string"&gt;'...'&lt;/span&gt;)
        .pipe(...)
        .pipe(...)
        &lt;span class="hljs-comment"&gt;// 直到任务的最后一步&lt;/span&gt;
        .pipe(...);
    &lt;span class="hljs-keyword"&gt;return&lt;/span&gt; stream;
});
</code></pre>
</div>

<p>至此，你已经可以使用 gulp.js 完成绝大多数的构建工作了。下一步，我也为你准备了几条建议：</p>

<ol>
  <li>花点时间浏览一下 <a href="http://gulpjs.com/plugins/">gulp.js 插件库</a>，大致了解下利用已有的插件你都可以做哪些事情</li>
  <li>对于常用的插件，仔细阅读它们自己的文档，以便发挥出它们最大的功效</li>
  <li>抽时间学习 gulp.js API，特别是 <code class="highlighter-rouge">gulp.task()</code> 里关于任务体的详细描述，学会如何执行回调函数（callback），如何返回 <code class="highlighter-rouge">promise</code> 等等</li>
  <li>尝试编写适合自己工作流程和习惯的任务，如果它工作良好，把它做成插件发布给大家吧！</li>
</ol>

<p>转至：http://segmentfault.com/blog/nightire/1190000000435599</p>

<p>未经允许不得转载：<a href="http://kongqia.com">空洽网</a> » <a href="http://kongqia.com/33586.html">“流式”前端构建工具—gulp.js 简介</a></p>


        </section>

        <footer class="post-footer">

        
        
        
        

            <section class="share">
                <h4>Share this post</h4>
                <a class="icon-twitter" href="https://twitter.com/intent/tweet?text=%E2%80%9C%E6%B5%81%E5%BC%8F%E2%80%9D%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E2%80%94gulp.js%20%E7%AE%80%E4%BB%8B&amp;url=/2015/01/31/e6-b5-81-e5-bc-8f-e5-89-8d-e7-ab-af-e6-9e-84-e5-bb-ba-e5-b7-a5-e5-85-b7-gulp-js-e7-ae-80-e4-bb-8b.html"
                    onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <span class="hidden">Twitter</span>
                </a>
                <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=/2015/01/31/e6-b5-81-e5-bc-8f-e5-89-8d-e7-ab-af-e6-9e-84-e5-bb-ba-e5-b7-a5-e5-85-b7-gulp-js-e7-ae-80-e4-bb-8b.html"
                    onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <span class="hidden">Facebook</span>
                </a>
                <a class="icon-google-plus" href="https://plus.google.com/share?url=/2015/01/31/e6-b5-81-e5-bc-8f-e5-89-8d-e7-ab-af-e6-9e-84-e5-bb-ba-e5-b7-a5-e5-85-b7-gulp-js-e7-ae-80-e4-bb-8b.html"
                   onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <span class="hidden">Google+</span>
                </a>
            </section>

            
            

        </footer>

    </article>
</main>


<aside class="read-next">
    
    <a class="read-next-story no-cover" href="/2015/09/12/mac-os-e7-bb-88-e7-ab-af-e9-87-8c-e4-bd-bf-e7-94-a8-solarized-e9-85-8d-e8-89-b2-e6-96-b9-e6-a1-88.html">
        <section class="post">
            <h2>Mac OS终端里使用 Solarized 配色方案</h2>
            <p>相信长期浸泡在终端和代码的小伙伴们都有一套自己喜爱的配色方案。以前一直在用简单、适合阅读的 Terminal.app 配色方案，换到 MacBook Pro with Retina display 后发现这个配色时间看长了眼睛有点累。不断有人推荐 Solarized，看了一些截图，感觉还不错，决定试一下。

&hellip;</p>
        </section>
    </a>
    
    
    <a class="read-next-story prev no-cover" href="/2015/01/21/macbook-e5-bc-80-e6-9c-ba-e9-bb-91-e5-b1-8f-e8-a7-a3-e5-86-b3-e5-8a-9e-e6-b3-95.html">
        <section class="post">
            <h2>MacBook开机黑屏解决办法</h2>
            <p>
  开机时长按R+P+command+option


&hellip;</p>
        </section>
    </a>
    
</aside>


        
        <footer class="site-footer clearfix">
            <section class="copyright"><a href=""></a> &copy; 2020</section>
            <section class="poweredby">Casper theme by <a href="https://ghost.org">Ghost</a>, adopted to Jekyll by <a href="https://github.com/Jinmo/jekyll-casper">Jinmo</a></section>
        </footer>

    </div>

    
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
    
    
    
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    
    <script type="text/javascript" src="/assets/js/index.js"></script>

</body>
</html>
